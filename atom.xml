<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://L0ne1yWind.github.io</id>
    <title> 404 NOT FOUND！</title>
    <updated>2021-08-12T11:10:04.248Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://L0ne1yWind.github.io"/>
    <link rel="self" href="https://L0ne1yWind.github.io/atom.xml"/>
    <subtitle> NOT FOUND！</subtitle>
    <logo>https://L0ne1yWind.github.io/images/avatar.png</logo>
    <icon>https://L0ne1yWind.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021,  404 NOT FOUND！</rights>
    <entry>
        <title type="html"><![CDATA[FastJson反序列化漏洞]]></title>
        <id>https://L0ne1yWind.github.io/post/fastjson-fan-xu-lie-hua-lou-dong/</id>
        <link href="https://L0ne1yWind.github.io/post/fastjson-fan-xu-lie-hua-lou-dong/">
        </link>
        <updated>2021-08-12T10:32:09.000Z</updated>
        <content type="html"><![CDATA[<p>FastJson序列化和反序列化的函数</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">JSON.toJSONString(Object)</td>
<td style="text-align:center">将对象序列化<code>json</code>格式</td>
</tr>
<tr>
<td style="text-align:center">JSON.toJSONString(Object，SerializerFeature.WriteClassName)</td>
<td style="text-align:center">将对象序列化<code>json</code>格式，并且记录对象所属类的信息</td>
</tr>
<tr>
<td style="text-align:center">JSON.parse(Json)</td>
<td style="text-align:center">将<code>json</code>格式返回为对象（但是反序列化类对象没有@type时会报错）</td>
</tr>
<tr>
<td style="text-align:center">JSON.parseObject(Json)</td>
<td style="text-align:center">返回对象是<code>com.alibaba.fastjson.JSONObject</code>类</td>
</tr>
<tr>
<td style="text-align:center">JSON.parseObject(Json，Object.class)</td>
<td style="text-align:center">返回对象会根据<code>json</code>中的<code>@type</code>来决定</td>
</tr>
<tr>
<td style="text-align:center">JSON.parseObject(Json，Object.class，Feature.SupportNonPublicField)</td>
<td style="text-align:center">会把<code>json</code>数据对应的类中的私有成员也给还原</td>
</tr>
</tbody>
</table>
<p>声明一个People类</p>
<pre><code class="language-java">package test;

public class People {
	public String Name;

	private double money;

	public People() {
		System.out.println(&quot;触发了构造方法&quot;);
	}

	public String getName() {
		System.out.println(&quot;触发了getName&quot;);
		return Name;
	}

	public void setName(String name) {
		System.out.println(&quot;触发了setName&quot;);
		this.Name = name;
	}

	public double getMoney() {
		System.out.println(&quot;触发了getMoney&quot;);
		return money;
	}

	public void setMoney(double money) {
		System.out.println(&quot;触发了setMoney&quot;);
		this.money = money;
	}

}
</code></pre>
<p>JSON序列化方法传入<code>SerializerFeature.WriteClassName</code>时，序列化结果会在开头出现<code>@type</code>字段，其值为进行序列化的全类名（包名+类名），将带有@type字段的序列化数据进行反序列化会得到对应的实例类对象。</p>
<pre><code class="language-java">package test;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.Feature;
import com.alibaba.fastjson.parser.ParserConfig;
import com.alibaba.fastjson.serializer.SerializerFeature;

public class FastJSONTest {
	public static void main(String[] args) {
		// 初始化
		People s = new People();
		s.setName(&quot;张三&quot;);
		s.setMoney(22222);
		ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
		// 序列化
		System.out.println(&quot;----------序列化----------&quot;);
		String ser1 = JSON.toJSONString(s);
		System.out.println(&quot;Serializer1 = &quot; + ser1);
		String ser2 = JSON.toJSONString(s, SerializerFeature.WriteClassName);
		System.out.println(&quot;Serializer2 = &quot; + ser2);
		// 反序列化
		System.out.println(&quot;----------反序列化----------&quot;);
		System.out.println(JSON.parse(ser1) + &quot;\n&quot;);
		System.out.println(JSON.parseObject(ser1).getClass().getName() + &quot;\n&quot;);
		System.out.println(JSON.parseObject(ser1, People.class) + &quot;\n&quot;);
		System.out.println(JSON.parseObject(ser1, People.class, Feature.SupportNonPublicField) + &quot;\n&quot;);
		System.out.println(&quot;	----------------&quot;);
		System.out.println(JSON.parse(ser2) + &quot;\n&quot;);// 触发类的构造函数、set方法
		System.out.println(JSON.parseObject(ser2) + &quot;\n&quot;);// 触发类的构造函数、set、get方法
		System.out.println(JSON.parseObject(ser2, Object.class) + &quot;\n&quot;);// 触发类的构造函数、set方法
		System.out.println(JSON.parseObject(ser2, Object.class, Feature.SupportNonPublicField) + &quot;\n&quot;);// 触发类的构造函数、set方法
	}
}
</code></pre>
<p>输出如下</p>
<pre><code class="language-html">触发了构造方法
触发了setName
触发了setMoney
----------序列化----------
触发了getMoney
触发了getName
Serializer1 = {&quot;Name&quot;:&quot;张三&quot;,&quot;money&quot;:22222.0,&quot;name&quot;:&quot;张三&quot;}
触发了getMoney
触发了getName
Serializer2 = {&quot;@type&quot;:&quot;test.People&quot;,&quot;Name&quot;:&quot;张三&quot;,&quot;money&quot;:22222.0,&quot;name&quot;:&quot;张三&quot;}
----------反序列化----------
{&quot;money&quot;:22222.0,&quot;name&quot;:&quot;张三&quot;,&quot;Name&quot;:&quot;张三&quot;}

com.alibaba.fastjson.JSONObject

触发了构造方法
触发了setMoney
触发了setName
test.People@7ab2bfe1

触发了构造方法
触发了setMoney
触发了setName
test.People@497470ed

	----------------
触发了构造方法
触发了setMoney
触发了setName
test.People@6438a396

触发了构造方法
触发了setMoney
触发了setName
触发了getMoney
触发了getName
{&quot;money&quot;:22222.0,&quot;name&quot;:&quot;张三&quot;,&quot;Name&quot;:&quot;张三&quot;}

触发了构造方法
触发了setMoney
触发了setName
test.People@6477463f

触发了构造方法
触发了setMoney
触发了setName
test.People@3d71d552
</code></pre>
<p>得出如下结论：</p>
<ol>
<li>序列化会触发set方法</li>
<li>反序列化会触发构造、set方法</li>
<li><code>当使用JSON.parseObject方法不指定类进行反序列化时会额外触发get方法</code></li>
</ol>
<p>跟进JSON.parseObject发现它比其他方式多了个toJSON操作，调用目标类的get方法得到对象的属性值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL注入]]></title>
        <id>https://L0ne1yWind.github.io/post/sql-zhu-ru/</id>
        <link href="https://L0ne1yWind.github.io/post/sql-zhu-ru/">
        </link>
        <updated>2021-08-11T10:45:13.000Z</updated>
        <content type="html"><![CDATA[<p>啊啊啊啊啊啊啊</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java反序列化漏洞]]></title>
        <id>https://L0ne1yWind.github.io/post/java-fan-xu-lie-hua-lou-dong/</id>
        <link href="https://L0ne1yWind.github.io/post/java-fan-xu-lie-hua-lou-dong/">
        </link>
        <updated>2021-08-11T10:44:59.000Z</updated>
        <content type="html"><![CDATA[<p>test</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://L0ne1yWind.github.io/post/hello-gridea/</id>
        <link href="https://L0ne1yWind.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>